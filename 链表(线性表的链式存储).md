#### 链表

##### 链表节点

![image-20230715150511540](https://cdn.jsdelivr.net/gh/Creek1024/Typora_img/img/2023/07/15/20230715150511.png)

##### 链表的头指针和头节点

![image-20230715141240150](https://cdn.jsdelivr.net/gh/Creek1024/Typora_img/img/2023/07/15/20230715141240.png)

==有无头节点，与L（头指针）的位置有关==

#### 链表结构体定义

```c
typedef struct lnode {
    int data;
    struct lnode *next;
}lnode,*linklist;
//
linklist p;
lnode *l;
//这两句话效果一样
lnode *l;
l=(lnode*)malloc(sizeof(lnode));
```



------



#### 遍历输出单链表L中各节点的值

```c
void foreach(linklist l){
    lnode *p=l->next;
    //无头节点时候
    //lnode *P =l;
    while(p!=null){
        printf("%d",p->data);
        p=p->next;
    }
}
```



-----



#### 单链表的按位查询和按值查询

###### 有一个带头结点的单链表L，查找第i个节点的位置，存在返回指针，不存在返回null

```c
//定义链表结构体
typedef struct lnode{
    int data;
    struct lnode *next;
}lnode,*linklist;
linklist select(linklist l,int i){
    if(i<1)
    return null;
    lnode *p=l;
    int k=0;
    while(p!=null){
        k++;
        if (k==i){
            return p;
        }
        p=p->next;
    }
    if(k<i)
    return null;
}
/*
linklist select(linklist l,int i){
    if(i<1)
    return null;
    lnode *p=l.next;
    int k=1;
    while(p!=null&&k<i){
        p=p->next;
        k++;
    }
    return p;
}
```

###### 查找第一个节点数值为e的元素，存在返回指针，不存在返回null

```c
linklist sel_e(linklist l,int e){
    lnode *p=l->next
    while(p!=null&&p->data!=e){
        p=p->next;
    }
    return p;
}
```



------



#### ==头插法==建立单链表

###### 采用头插法在头指针L处建立一个带头结点的单链表，输入-1表示结束，结果返回建立的单链表

```c
linklist l_headInsert(linklist &l){
    l=(lnode*)malloc(sizeof(lnode));
    l->next=null;           //非常重要
    lnode *s;
    int x;
    scanf("%d",&x);
    while(x!=-1){
       s=(lnode*)malloc(sizeof(lnode));
       s->next=l.next;
       s->data=x;
       l->next=s; 
       scanf("%d",&x);
    }
    return l;
}
```



------



#### ==尾插法==建立单链表

采用尾插法在头指针L处建立一个带头结点的单链表，输入-1表示结束，结果返回建立的单链表

```c
typedef struct Lnode{
    int data;
    struct Lnode *next;
}Lnode,*Linklist;
void inser_end(Linklist &l){
    l=(Lnode*)malloc(sizeof(Lnode));
    Lnode *s,*r=l;         //因为是新建，尾指针就等于l
    int x;
    scanf("%d",x);
    while(x!=0){
     s=(Lnode*)malloc(sizeof(Lnode));
     s->data=x;
     r->next=s;
     r=s;
     scanf("%d",x);
    }
    s->next=null;
    return l;
}
```



-----



#### 单链表的==就地逆置==

###### ==逆置则为头插==

###### 带头结点的单链表的就地逆置，就地代表空间复杂度为S（1）

```c
void reverse (Linklist &l){
    Lnode *p,*r;   //防断裂指针
    p=l->next;
    l->next=null;
    while(p!=null){
        r=p->next;
        p->next=l->next;
        l->next=p;
        p=r;
    }
}
```



-----



#### 将一个单链表分成两个单链表且==相对顺序不变==

###### ==顺序不变则为尾插==

###### 将一个带头结点的链表A，分解为两个带头结点的单链表A和B

使得A表中含有原表中序号为奇数的元素，而B表中含有原表中序号为偶数的元素，且保持相对顺序不变，最后返回B表

```c
Linklist creat_a_b(Linklist &a){
    Lnode *b=(Linklist)malloc(sizeof(Lnode));
    Linklist p=a->next,ra=a,rb=b;   //ra rb为尾指针 p为遍历指针
    a->next=null;
    rb->next=null;
    while(p!=null){
        ra->next=p;
        ra=p;
        if(p!=null){
            rb->next=p;
            rb=p;
        }
    }
    ra->next=null;
    rb->next=null;
    return b;
}
```



-----



#### 将一个单链表分解为两个单链表且相对顺序改变

带头结点的单链表A{a1,b1,a2,b2,……,an,bn}分解为两个带头结点的单链表A，B，使得A={a1,a2,a3……,an} ，B={bn,bn-1,……,b2,b1}

```c
void creat(Linklist &a){
    Linklist b=(lnode*)malloc(sizeof(lnode));
    b->next=null;
    Linklist r,ra=a,p=a->next; // r为防断裂指针 p为遍历指针 ra为尾指针
    a->next=null;
    while(p!=null){
        ra->next=p;
        ra=p;
        p=p->next;
        if(p!=null){
            r=p->next;
            p->next=b->next;
            b->next=p;
            p=r;
        }
    }
    ra->next=null;
}
```



------



#### 两个有序单链表合并成一个有序单链表

###### 假设有两个按元素递增次序排列的，带头结点的单链表。归并为一个按元素值递减次序排列的单链表，并要求利用原来两个单链表的头结点存放归并后的单链表

```c
void merge(linklist &a,linklist &b){
    linklist p=a->next,q=b->next,r;
    r=a->next;                          //使用a表头节点作为合并后的头结点
    a->next=null;
    while(p!=null&&q!=null){
        if(p->data<q->data){
            r=p;
            p->next=a->next;
            a->next=p;
            p=r->next;
        }
        else{
            r=q;
            q->next=b->next;
            b->next=q;
            q=r->next;
        }
    }
    while(p!=null||q!=null){
        if(p=null)
        p=q;
        r=p;
        p->next=a->next;
        a-next=p;
        p=r->next; 
    }
    
}


/*void merge(linklist a,linklist b,linklist &c){
    c=(linklist)malloc(sizeof(lnode));
    c->next=null;                              //这是新建一个链表的方法 不使用原头结点
    linklist ra=a->next,rb=b->next,k;
    while(ra!=null&&rb!=null){
        k=(lnode*)malloc(sizeof(lnode));
        if(ra->data<rb->data){
            k->next=c->next;
            k->data=ra->data;
            c->next=k;
            ra=ra->next;
        }else{
            k->next=c->next;
            k->data=rb->data;
            c->next=k;
            rb=rb->next;
        }
    }
    while(ra!=null){
        k=(lnode*)malloc(sizeof(lnode));
        k->data=ra->data;
        k->next=c->next;
        c->next=k;
        ra=ra->next;
    }
    while(rb!=null){
        k=(lnode*)malloc(sizeof(lnode));
        k->data=rb->data;
        k->next=c->next;
        c->next=k;
        rb=rb->next;
    }
}*/
```



------



#### 删除单链表中最小值结点（带头结点与不带头结点）

###### 试编写在单链表L中删除一个最小值节点的高效算法（假设最小值结点唯一）

###### 头结点

```c
void del_min(linklist &l){
    linklist pre,min,minpre,p=l->next;
    pre=l;
    min=p;
    minpre=pre;
    while(p!=null){
        if(p->data<min->data){
            minp=p;
            minpre=pre;
        }
        p=p->next;
        pre=pre->next;
    }
    minpre->next=min->next;
    free(minp);
}
```

###### 不带头结点

```c
void del(linklist &l){
    linklist o;
    o=(linklist)malloc(sizeof(lnode));
    o->next=l;
    linklist minp,minpre,p,pre;
    p=o->next;
    pre=o;
    minp=pre;
    minp=p;
    while(p!=null){
        if(p->data<min->data){
            minp=p;
            minpre=pre;
        }
        pre=pre->next;
        p=p->next;
    }
    minpre->next=minp->next;
    free(minp);
    l=o->next;
    free(o);
}
```

