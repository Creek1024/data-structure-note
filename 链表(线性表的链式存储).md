#### 链表

##### 链表节点

![image-20230715150511540](https://cdn.jsdelivr.net/gh/Creek1024/Typora_img/img/2023/07/15/20230715150511.png)

##### 链表的头指针和头节点

![image-20230715141240150](https://cdn.jsdelivr.net/gh/Creek1024/Typora_img/img/2023/07/15/20230715141240.png)

==有无头节点，与L（头指针）的位置有关==

#### 链表结构体定义

```c
typedef struct lnode {
    int data;
    struct lnode *next;
}lnode,*linklist;
//
linklist p;
lnode *l;
//这两句话效果一样
lnode *l;
l=(lnode*)malloc(sizeof(lnode));
```



------



#### 遍历输出单链表L中各节点的值

```c
void foreach(linklist l){
    lnode *p=l->next;
    //无头节点时候
    //lnode *P =l;
    while(p!=null){
        printf("%d",p->data);
        p=p->next;
    }
}
```



-----



#### 单链表的按位查询和按值查询

###### 有一个带头结点的单链表L，查找第i个节点的位置，存在返回指针，不存在返回null

```c
//定义链表结构体
typedef struct lnode{
    int data;
    struct lnode *next;
}lnode,*linklist;
linklist select(linklist l,int i){
    if(i<1)
    return null;
    lnode *p=l;
    int k=0;
    while(p!=null){
        k++;
        if (k==i){
            return p;
        }
        p=p->next;
    }
    if(k<i)
    return null;
}
/*
linklist select(linklist l,int i){
    if(i<1)
    return null;
    lnode *p=l.next;
    int k=1;
    while(p!=null&&k<i){
        p=p->next;
        k++;
    }
    return p;
}
```

###### 查找第一个节点数值为e的元素，存在返回指针，不存在返回null

```c
linklist sel_e(linklist l,int e){
    lnode *p=l->next
    while(p!=null&&p->data!=e){
        p=p->next;
    }
    return p;
}
```



------



#### ==头插法==建立单链表

###### 采用头插法在头指针L处建立一个带头结点的单链表，输入-1表示结束，结果返回建立的单链表

```c
linklist l_headInsert(linklist &l){
    l=(lnode*)malloc(sizeof(lnode));
    l->next=null;           //非常重要
    lnode *s;
    int x;
    scanf("%d",&x);
    while(x!=-1){
       s=(lnode*)malloc(sizeof(lnode));
       s->next=l.next;
       s->data=x;
       l->next=s; 
       scanf("%d",&x);
    }
    return l;
}
```



------



#### ==尾插法==建立单链表

采用尾插法在头指针L处建立一个带头结点的单链表，输入-1表示结束，结果返回建立的单链表

```c
typedef struct Lnode{
    int data;
    struct Lnode *next;
}Lnode,*Linklist;
void inser_end(Linklist &l){
    l=(Lnode*)malloc(sizeof(Lnode));
    Lnode *s,*r=l;         //因为是新建，尾指针就等于l
    int x;
    scanf("%d",x);
    while(x!=0){
     s=(Lnode*)malloc(sizeof(Lnode));
     s->data=x;
     r->next=s;
     r=s;
     scanf("%d",x);
    }
    s->next=null;
    return l;
}
```



-----



#### 单链表的==就地逆置==

###### ==逆置则为头插==

###### 带头结点的单链表的就地逆置，就地代表空间复杂度为S（1）

```c
void reverse (Linklist &l){
    Lnode *p,*r;   //防断裂指针
    p=l->next;
    l->next=null;
    while(p!=null){
        r=p->next;
        p->next=l->next;
        l->next=p;
        p=r;
    }
}
```



-----



#### 将一个单链表分成两个单链表且==相对顺序不变==

###### ==顺序不变则为尾插==

###### 将一个带头结点的链表A，分解为两个带头结点的单链表A和B

使得A表中含有原表中序号为奇数的元素，而B表中含有原表中序号为偶数的元素，且保持相对顺序不变，最后返回B表

```c
Linklist creat_a_b(Linklist &a){
    Lnode *b=(Linklist)malloc(sizeof(Lnode));
    Linklist p=a->next,ra=a,rb=b;
    a->next=null;
    rb->next=null;
    while(p!=null){
        ra->next=p;
        ra=p;
        if(p!=null){
            rb->next=p;
            rb=p;
        }
    }
    ra->next=null;
    rb->next=null;
    return b;
}
```



-----



#### 将一个单链表分解为两个单链表且相对顺序改变

带头结点的单链表A{a1,b1,a2,b2,……,an,bn}分解为两个带头结点的单链表A，B，使得A={a1,a2,a3……,an} ，B={bn,bn-1,……,b2,b1}

```c
void creat(Linklist &a){
    Linklist b=(lnode*)malloc(sizeof(lnode));
    b->next=null;
    Linklist r,ra=a,p=a->next;
    a->next=null;
    while(p!=null){
        ra->next=p;
        ra=p;
        p=p->next;
        if(p!=null){
            r=p->next;
            p->next=b->next;
            b->next=p;
            p=r;
        }
    }
    ra->next=null;
}
```

