#### 链表

##### 链表节点

![image-20230715150511540](https://cdn.jsdelivr.net/gh/Creek1024/Typora_img/img/2023/07/15/20230715150511.png)

##### 链表的头指针和头节点

![image-20230715141240150](https://cdn.jsdelivr.net/gh/Creek1024/Typora_img/img/2023/07/15/20230715141240.png)

==有无头节点，与L（头指针）的位置有关==

#### 链表结构体定义

```c
typedef struct lnode {
    int data;
    struct lnode *next;
}lnode,*linklist;
//
linklist p;
lnode *l;
//这两句话效果一样
lnode *l;
l=(lnode*)malloc(sizeof(lnode));
```



------



#### 遍历输出单链表L中各节点的值

```c
void foreach(linklist l){
    lnode *p=l->next;
    //无头节点时候
    //lnode *P =l;
    while(p!=null){
        printf("%d",p->data);
        p=p->next;
    }
}
```



-----



#### 单链表的按位查询和按值查询

###### 有一个带头结点的单链表L，查找第i个节点的位置，存在返回指针，不存在返回null

```c
//定义链表结构体
typedef struct lnode{
    int data;
    struct lnode *next;
}lnode,*linklist;
linklist select(linklist l,int i){
    if(i<1)
    return null;
    lnode *p=l;
    int k=0;
    while(p!=null){
        k++;
        if (k==i){
            return p;
        }
        p=p->next;
    }
    if(k<i)
    return null;
}
/*
linklist select(linklist l,int i){
    if(i<1)
    return null;
    lnode *p=l.next;
    int k=1;
    while(p!=null&&k<i){
        p=p->next;
        k++;
    }
    return p;
}
```

###### 查找第一个节点数值为e的元素，存在返回指针，不存在返回null

```c
linklist sel_e(linklist l,int e){
    lnode *p=l->next
    while(p!=null&&p->data!=e){
        p=p->next;
    }
    return p;
}
```



------



#### ==头插法==建立单链表

###### 采用头插法在头指针L处建立一个带头结点的单链表，输入-1表示结束，结果返回建立的单链表

```c
linklist l_headInsert(linklist &l){
    l=(lnode*)malloc(sizeof(lnode));
    l->next=null;           //非常重要
    lnode *s;
    int x;
    scanf("%d",&x);
    while(x!=-1){
       s=(lnode*)malloc(sizeof(lnode));
       s->next=l.next;
       s->data=x;
       l->next=s; 
       scanf("%d",&x);
    }
    return l;
}
```



------



#### ==尾插法==建立单链表

采用尾插法在头指针L处建立一个带头结点的单链表，输入-1表示结束，结果返回建立的单链表

```c
typedef struct Lnode{
    int data;
    struct Lnode *next;
}Lnode,*Linklist;
void inser_end(Linklist &l){
    l=(Lnode*)malloc(sizeof(Lnode));
    Lnode *s,*r=l;         //因为是新建，尾指针就等于l
    int x;
    scanf("%d",x);
    while(x!=0){
     s=(Lnode*)malloc(sizeof(Lnode));
     s->data=x;
     r->next=s;
     r=s;
     scanf("%d",x);
    }
    s->next=null;
    return l;
}
```



-----



#### 单链表的==就地逆置==

###### 带头结点的单链表的就地逆置，就地代表空间复杂度为S（1）

```c
void reverse (Linklist &l){
    Lnode *p,*r;   //防断裂指针
    p=l->next;
    l->next=null;
    while(p!=null){
        r=p->next;
        p->next=l->next;
        l->next=p;
        p=r;
    }
}
```

