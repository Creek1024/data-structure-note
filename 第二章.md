## 顺序表



#### 顺序表的结构体定义

###### 固定分配内存

```c
#define MaxSize 100
typedef struct {
    int data[MaxSize];
    int length;
}sqlist;
sqlist l;
l.length=0;
l.data[0]=1;
l.length=l.length+1;
```

###### 动态分配内存

```c
typedef struct {
    int *data;
    int maxsize,length;
}seqlist;
seqlist *l;
l->data=(int*)malloc(sizeof(int)*100);
//动态分配了100内存
l->maxsize=100;
l->length=0;
```



----



#### 顺序表的遍历及输出

```c
void forReach(sqlist l)
{
    for (int i = 0, i <= l.length - 1, i++)
        printf("%d", l.data[i]);
}
```



-----



#### 查找顺序表中值为e的数据元素所在位置

###### 有一个顺序表L，其存储的所有数据类型均为不重复的正数，查找L中值为e的数据元素，若找到返回其下标，若不存在返回-1

```c
int select_e(sqlist l, int e)
{
    for (int i = 0; i < l.length; i++)
        if (l.data[i] == e)
            return i;
        return -1;
}
```



----



#### 查找顺序表第i个位置的数据

###### 有一个顺序表L，其存储的所有元素均为正数，查找第i个位置的数据元素并且返回其值



==注意点在于线性表中的位序从1开始==

==数组中元素下标从0开始==

```c
int seek(sqlist l,int i){
    if(i>=1&&i<l.length){
        return l.data[i-1];//
    }
    return -1;
}
```



----



#### 顺序表逆置且要求空间复杂度为O(1)

```c
void reverse(sqlist &l){
    int temp;
    for(int i=0;i<l.length/2;i++)//l.length等于5的时候l.length/2结果为2
    temp=l.data[i];
    l.data[i]=l.data[l.length-1-i];
    l.data[l.length-1-i]=temp; 
}
```

==交换原理==

<img src="https://cdn.jsdelivr.net/gh/Creek1024/Typora_img/img/2023/07/10/20230710165322.png" alt="image-20230710165315652" style="zoom:67%;" />

-----



#### 在顺序表第i位置插入元素e

###### 若i的输入不合法，则返回false，否则后移一位包括i的元素位置，

###### 顺序表长度加1，并在原先i处插入e，返回true

==i不能小于1，i不能大于l.length+1,填满时候不能进行插入操作==

```c
bool insert(sqlist &l,int i,int e){
    if(i<1||i>l.length+1)
    return false;
    if(l.length==MaxSize)
    return false;
    for(int k=l.length;k>=i;k--){
        l.data[k]=l.data[k-1];
    }
    l.data[i-1]=e;
    l.length++;
    return true;
}
```



-----



#### 有序顺序表插入元素X之后依然有序

###### 顺序表L，其中的元素递增有序排列，插入一个int型变量X后，保持该表有序递增，假设插入肯定成功，执行插入后，返回插入元素所在位置。

```c
int insert(sqlist &l,int x){
    int pos;
    for(int i=0;i<l.length;i++){
        if (l.data[i]>x){
        pos=i+1;
        break;
        }
        pos=l.length+1;
    }
    for(int k=l.length;k>=pos;k--){
        l.data[k]=l.data[k-1];
    }
    l.data[pos-1]=x;
    l.length++;
    return pos;
}
```

